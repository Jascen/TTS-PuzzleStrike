require("constants")

current_bank = {}

game_settings = {
  initialized = false,
  showLabels = false,
  rotateBank = true,
  enableTools = true
}

player_data = {
    Purple = {
        pile = 0,
        hand = 0,
        discard = 0,
        bag = 0,
        ongoing = 0
    },
    Red = {
        pile = 0,
        hand = 0,
        discard = 0,
        bag = 0,
        ongoing = 0
    },
    Green = {
        pile = 0,
        hand = 0,
        discard = 0,
        bag = 0,
        ongoing = 0
    },
    Blue = {
        pile = 0,
        hand = 0,
        discard = 0,
        bag = 0,
        ongoing = 0
    }
}

show = {
    Scoreboard = {
        Purple = {
            visible = true
        },
        Red = {
            visible = true
        },
        Green = {
            visible = true
        },
        Blue = {
            visible = true
        }
    }
}

----- Bank manipulation

--- Rotates the bank to look at the side of the board based on whose turn it is
function onPlayerTurnStart(current, previous)
    if previous == nil or previous == '' then return end

    local bankZone = getObjectFromGUID(constants.bank_zone)
    if bankZone == nil then return end

    local bankObjects = bankZone.getObjects()
    if bankObjects == nil then return end

    -- Build unique list of highest object count
    for _, o in pairs(getObjectFromGUID(constants.bank_zone).getObjects()) do
        if o.getLock() ~= true and o.tag == 'Tile' then
            local name = o.getName()
            if name ~= nil and name ~= "" then
                local bank_object = current_bank[name]
                if bank_object ~= nil then
                    local p = bank_object.position
                    o.setPositionSmooth({
                        p[1],
                        p[2] + 1,
                        p[3]
                    }, false, true)
                else
                    local bag = constants.bags[name]
                    if bag ~= nil and bag.id ~= nil then
                            getObjectFromGUID(bag.id).putObject(o)
                    end
                end
            end
        end
    end

  rotateBankForColor(current)
end

function rotateBankForColor(color)
    if game_settings.rotateBank == true then
      if color == "Purple" or color == "Red" then
        rotateBank(180)
      elseif color == "Green" or color == "Blue" then
        rotateBank(0)
      end
    end
end

function rotateBank(degree)

    -- Text labels
    local z = -1
    if degree == 180 then z = 1 end

    local i = 0
    for _, label in pairs(constants.labels) do
        local o = getObjectFromGUID(label)
        o.setPosition({
            x = -22.25 + (5 * i),
            y = 2,
            z = z
        })
        local rotation = o.getRotation()
        o.setRotation({
            rotation[1],
            degree + 180,
            rotation[3]
        })
        i = i + 1
    end

    for _, o in pairs(getObjectFromGUID(constants.bank_zone).getObjects()) do
        local rotation = o.getRotation()
        o.setRotation({
            rotation[1],
            degree,
            rotation[3]
        })
    end
end

----- Chip selection

-- key_src - A table of keys to draw from
-- count - The amount of keys to return
-- excluded_keys - A table of keys to skip over
-- RETURNS -- A list of keys
function getRandomChips(key_src, count, excluded_keys)
    if (key_src[1] == nil) then
        print('The chip source has no keys.')
        return {}
    end

    local i = 0
    local selectedKeys = {}
    while i < count do
        local index = key_src[math.random(1, #key_src)]
        if not setContains(selectedKeys, index) then
            if not setContains(excluded_keys, index) then
                addToSet(selectedKeys, index, constants.chip_obj[index])
                i = i + 1
            end
        end
    end

    return selectedKeys
end

-------- Table Value Tracking

function updateDeckSize(color)
    local o = player_data[color]
    local count = o.hand + o.discard + o.bag + o.ongoing
    UI.setAttribute(color .. "_deck", "text", count)
end

function onObjectEnterContainer(container, object)
    local container_id = container.getGUID()
    for color, o in pairs(constants.zones) do
        for key, id in pairs(o) do
            if container_id == id then
                if key == "deck" then
                    local count = countObjectsInContainer(container)
                    player_data[color].bag = count
                    updateDeckSize(color)
                end
            end
        end
    end
end

function onObjectLeaveContainer(container, object)
    if object.tag == 'Tile' then
        object.setCustomObject({
            stackable = false
        })
    end

    local container_id = container.getGUID()
    for color, o in pairs(constants.zones) do
        for key, id in pairs(o) do
            if container_id == id then
                if key == "deck" then
                    local count = countObjectsInContainer(container)
                    player_data[color].bag = count
                    updateDeckSize(color)
                end
            end
        end
    end
end

function onObjectEnterScriptingZone(zone, object)
    local zone_id = zone.getGUID()
    for color, o in pairs(constants.zones) do
        for key, id in pairs(o) do
            if zone_id == id then
                if key == "pile" then -- Count gem pile
                    local name = object.getName()
                    if name:match("%d Gem") then
                        local count = countGems(zone)
                        updateRow(color, count)
                    end

                    return
                elseif key == "discard" then -- Count discard
                    local count = countObjects(zone)
                    player_data[color].discard = count
                    updateDeckSize(color)
                elseif key == "hand" then -- Count hand
                    local count = countObjects(zone)
                    player_data[color].hand = count
                    UI.setAttribute(color .. "_hand", "text", count)
                    updateDeckSize(color)
                elseif key == "ongoing" then -- Count ongoing
                    local count = countObjects(zone)
                    player_data[color].ongoing = count
                    updateDeckSize(color)
                end
            end
        end
    end
end

function onObjectLeaveScriptingZone(zone, object)
    local zone_id = zone.getGUID()
    for color, o in pairs(constants.zones) do
        for key, id in pairs(o) do
            if zone_id == id then
                if key == "pile" then -- Count gem pile
                    local name = object.getName()
                    if name:match("%d Gem") then
                        local count = countGems(zone)
                        updateRow(color, count)
                    end

                    return
                elseif key == "discard" then -- Count discard
                    local count = countObjects(zone)
                    player_data[color].discard = count
                    updateDeckSize(color)
                elseif key == "hand" then -- Count hand
                    local count = countObjects(zone)
                    player_data[color].hand = count
                    UI.setAttribute(color .. "_hand", "text", count)
                    updateDeckSize(color)
                elseif key == "ongoing" then -- Count ongoing
                    local count = countObjects(zone)
                    player_data[color].ongoing = count
                    updateDeckSize(color)
                end
            end
        end
    end
end

function updateRow(color, count)
    UI.setAttribute(color .. "_pile", "text", count)
    if 9 < count then
        UI.setAttribute(color, "color", "rgba(1, 0, 0, 0.31)")
    elseif 8 < count then
        UI.setAttribute(color, "color", "rgba(1, 0.5, 0, 0.31)")
    elseif 5 < count then
        UI.setAttribute(color, "color", "rgba(1, 1, 0, 0.31)")
    elseif 2 < count then
        UI.setAttribute(color, "color", "rgba(0, 1, 0, 0.31)")
    else
        UI.setAttribute(color, "color", "rgba(0, 0, 0, 0)")
    end
end

function countObjectsInContainer(container)
    local count = 0
    if container ~= nil then for _, object in ipairs(container.getObjects()) do count = count + 1 end end

    return count
end

function countObjects(zone)
    local count = 0
    if zone ~= nil then 
      for _, object in ipairs(zone.getObjects()) do 
        local id = object.getGUID()
        -- Never count the player mat as an object
        if isPlayerMat(id) ~= true then
          count = count + getAmount(object) 
        end
      end
    end

    return count
end

function isPlayerMat(id)
  for i=1,#constants.player_mats do
     if constants.player_mats[i] == id then 
        return true
     end
  end
  return false
end

function countGems(zone)
    local count = 0
    if zone ~= nil then for _, object in ipairs(zone.getObjects()) do count = count + countGem(object) end end

    return count
end

function getAmount(object)
    local amount = object.getQuantity()
    if amount < 1 then return 1 end
    return amount
end

function countGem(object)
    local name = object.getName()
    if name:match("%d Gem") then return getAmount(object) * string.match(name, "%d") end

    return 0
end

----- Placement

function buildBank_ChipRows(collection)
    local sorted = {}
    local item_count = 0
    for _, chip in pairs(collection) do
        item_count = item_count + 1
        sorted[item_count] = chip
    end
    table.sort(sorted, sortFunction)

    local item_width = 2.5
    local left_pad = 2.5
    local item_offset_x = item_width * item_count
    local pad_offset_x = left_pad * (item_count - 1) -- No left pad for the first item
    local item_offset_z = -2.5

    local start = {
        x = 1.25 - (item_offset_x + pad_offset_x) / 2, -- Offset by half
        y = 2.5,
        z = 0 - item_offset_z
    }

    local column = 0
    for _, chip in pairs(sorted) do
        local position = {
            start.x + (item_width * column) + (left_pad * column),
            start.y,
            start.z
        }

        -- Create a stack for the bank
        for i = 1, 5 do getChip(chip.key).setPosition(position) end

        current_bank[chip.name] = {
            position = position
        }

        column = column + 1
    end
end

function getChip(chip_id)
    local clone = getObjectFromGUID(constants.chip_obj[chip_id].id).clone()
    clone.setCustomObject({
        stackable = true
    })
    clone.locked = false

    return clone
end

------ Utility

-- src - A table
-- RETURNS -- The original table's keys in a new table
function extractKeysFromTable(src)
    local keys = {}
    for key, value in pairs(src) do
        keys[#keys + 1] = key -- Store keys in another table
    end

    return keys
end

--- Sorts the provided chips by cost and then by key (= name)
function sortFunction(a, b)
    return a.cost < b.cost or a.cost == b.cost and a.key < b.key
end

-- src - A table
-- key - The key to add
-- value - The value associated with the key
function addToSet(src, key, value)
    src[key] = value
end

-- src - A table
-- key - The key to remove
function removeFromSet(src, key)
    src[key] = nil
end

-- src - A table
-- key - The key to check for
-- RETURNS -- Whether or not a table has a value set for the given key
function setContains(set, key)
    return set[key] ~= nil
end

----- ?????

function onLoad(save_state)
    if save_state ~= "" then
        local loaded_data = JSON.decode(save_state)
        player_data = loaded_data.player_data
        
        -- TODO: Verify this works as expected
        if loaded_data.current_player ~= nil then
            Turns.turn_color = loaded_data.current_player
        end

        if loaded_data.game_settings ~= nil then
            game_settings = loaded_data.game_settings
        end
    end

    applyGameSettings()
    MegaFreeze()
    updatePlayers()
end

function applyGameSettings()
    if game_settings.initialized == true then
      UI.setAttribute("NewGame", "active", false)
    else
      UI.setAttribute("NewGame", "active", true)
    end

    if game_settings.enableTools == true then
        UI.setAttribute("ToolManager", "active", true)
        UI.setAttribute("ShowTools", "isOn", true)
      else
        UI.setAttribute("ToolManager", "active", false)
        UI.setAttribute("ShowTools", "isOn", false)
    end

    if game_settings.showLabels == true then
        UI.setAttribute("ShowBankLabels", "isOn", true)
      else
        UI.setAttribute("ShowBankLabels", "isOn", false)
    end

    if game_settings.rotateBank == true then
        UI.setAttribute("RotateBank", "isOn", true)
        rotateBankForColor(Turns.turn_color)
      else
        UI.setAttribute("RotateBank", "isOn", false)
    end
end

function onSave()
    saved_data = JSON.encode({
        player_data = player_data,
        game_settings = game_settings,
        current_player = Turns.turn_color
    })

    -- saved_data = ""
    return saved_data
end

function updatePlayers()
    local players = Player.getPlayers()
    local seats = {}
    for _, color in pairs(Player.getAvailableColors()) do seats[color] = false end

    for _, player in pairs(players) do if player.color ~= nil and player.color ~= "" then seats[player.color] = player.steam_name end end

    for color, player in pairs(seats) do
        if player ~= nil and player ~= "" and player ~= false then
            UI.setAttribute(color .. "_name", "text", player)
            UI.setAttribute(color, "active", true)
        else
            UI.setAttribute(color, "active", false)
        end
    end
end

function onPlayerChangeColor(color)
    updatePlayers()
end

-- UI - Host Options --
function toggleHostOptions()
  local opened = UI.getAttribute("HostOptions_content", "active")
  if opened == "False" then
    UI.setAttribute("HostOptions", "height", 75)
    UI.setAttribute("HostOptions_content", "active", true)
  else
    UI.setAttribute("HostOptions", "height", 25)
    UI.setAttribute("HostOptions_content", "active", false)
  end
end

function toggleSettings()
  local opened = UI.getAttribute("Settings", "active")
  if opened == "True" then
      UI.setAttribute("Settings", "active", false)
  else
      UI.setAttribute("Settings", "active", true)
  end
end

function toggleEnableTools(_, value)
    if value == "True" then
      game_settings.enableTools = true
      UI.setAttribute("ToolManager", "active", true)
    else
      game_settings.enableTools = false
      UI.setAttribute("ToolManager", "active", false)
    end
end

function toggleRotateBank(_, value)
    if value == "True" then
      game_settings.rotateBank = true
      rotateBankForColor(Turns.turn_color)
    else
      game_settings.rotateBank = false
    end
end

-- UI - Host Options --

-- UI - New Game --
mode = constants.modes.random

function togglePlaceholder(_, value)
    if value == "True" then
      game_settings.showLabels = true
    else
      game_settings.showLabels = false
    end

    for i, id in ipairs(constants.labels) do
        local label = getObjectFromGUID(id)
        if game_settings.showLabels == true then
            label.TextTool.setValue(tostring(i))
        else
            label.TextTool.setValue(" ")
        end
    end
end

function closeSettings()
  UI.setAttribute("Settings", "active", false)
end

function selectMode(player, option, id)
    if option == "Random" then
        mode = constants.modes.random
    elseif option == "Manual" then
        mode = constants.modes.manual
    elseif option == "Draft" then
        mode = constants.modes.draft
    elseif option == "First Game" then
        mode = constants.modes.beginner
    end
end

function setupDefaultBoard()
  local setup = getObjectFromGUID("5e08f3")
  if setup ~= nil then
    for _, o in pairs(constants.bags) do
      local infinite_bag = setup.takeObject({guid = o.infinite})
      if infinite_bag ~= nil then
        local clone = infinite_bag.takeObject()
        if clone ~= nil then
          setup.putObject(infinite_bag)
          clone.setPositionSmooth(o.position, false, true)
          clone.setLock(true)
        end
      end
    end
  end
end

--- Initiates the process to build a bank for the provided mode
-- mode - The bank building mode
function startGame()
  if game_settings.initialized == true then return end

  game_settings.initialized = true

  draftBoard = getObjectFromGUID(draftBoard_id)
  chip_keys = extractKeysFromTable(constants.chip_obj)

  setupDefaultBoard()

    local chips = nil
    if mode == constants.modes.random then
        -- TODO: Promote?
        -- TODO: Place stage?
        chips = getRandomChips(chip_keys, 10, {})
        buildBank_ChipRows(chips)
        -- destroyDraftBoard()
    elseif mode == constants.modes.beginner then
        -- TODO: Promote?
        -- TODO: Place stage?

        chips = {}
        chips["combos_are_hard"] = constants.chip_obj["combos_are_hard"]
        chips["draw_three"] = constants.chip_obj["draw_three"]
        chips["gem_essence"] = constants.chip_obj["gem_essence"]
        chips["knockdown"] = constants.chip_obj["knockdown"]
        chips["one_of_each"] = constants.chip_obj["one_of_each"]
        chips["one_two_punch"] = constants.chip_obj["one_two_punch"]
        chips["risky_move"] = constants.chip_obj["risky_move"]
        chips["sale_prices"] = constants.chip_obj["sale_prices"]
        chips["self_improvement"] = constants.chip_obj["self_improvement"]
        chips["sneak_attack"] = constants.chip_obj["sneak_attack"]
        buildBank_ChipRows(chips)
        -- destroyDraftBoard()
    elseif mode == constants.modes.manual then
        -- Do nothing
    else
        draftBoard.setPosition({
            0,
            1.01,
            0
        })
        draftBoard.lock()
        draftBoard.interactable = false

        -- TODO: Implement draft mode
        if mode == constants.modes.draft then
            chips = getRandomChips(chip_keys, 5, staged_chips)
            displayCandidates(chips, true)
        elseif mode == constants.modes.manual then
            displayCandidates(constants.chip_obj, false)
        end
    end

    UI.setAttribute("NewGame", "active", false)
    local characterObject = getObjectFromGUID(constants.character_sheet)
    if characterObject ~= nil then
        local players = Player.getPlayers()
        for _, player in pairs(players) do
            characterObject.call('toggleCharacterList', player)
        end
    end
    
    Turns.enable = true
end
-- UI - New Game --

-- UI - Character Selection --

function makeDeck(player)
    local playerHand = player.getPlayerHand()
    if playerHand then
      local crash_bag = getObjectFromGUID(constants.bags["Crash"].id)
      local gem_bag = getObjectFromGUID(constants.bags["1 Gem"].id)
      if crash_bag ~= nil and gem_bag ~= nil then
        crash_bag.deal(1, player.color)
        gem_bag.deal(6, player.color)
        return true
      end
    end
end

-- UI - Character Selection --

-- UI - Scoreboard --
function minimizeScoreboard(player)
    showForPlayer(player, "Scoreboard_content", show["Scoreboard"])
end

function showForPlayer(player, panel, shown)
    local color = player.color
    local opened = self.UI.getAttribute(panel, "visibility")
    if opened == nil then opened = "" end
    if opened:find(color) then
        opened = opened:gsub("|" .. color, "")
        opened = opened:gsub(color .. "|", "")
        opened = opened:gsub(color, "")
        self.UI.setAttribute(panel, "visibility", opened)
        if opened == "" then
            self.UI.setAttribute(panel, "active", "false")
            shown[color].visible = false
        end
    else
        if shown[color].visible == false then
            self.UI.setAttribute(panel, "active", "true")
            self.UI.setAttribute(panel, "visibility", color)
            shown[color].visible = true
        else
            self.UI.setAttribute(panel, "visibility", opened .. "|" .. color)
        end
    end
end
-- UI - Scoreboard --

-- UI - Tools --
function discardHand(player)
    local hand = getObjectFromGUID(constants.zones[player.color].hand)
    if hand ~= nil then
        local objects = {}
        for _, object in ipairs(hand.getObjects()) do
            -- If it's face down, don't discard it. They chose to piggy bank it.
            if object.is_face_down ~= true then table.insert(objects, object) end
        end

        local discard = getObjectFromGUID(constants.zones[player.color].discard)
        if discard ~= nil then
            moveAllToDiscard({
                discard,
                objects
            })
        end
    end
end

function moveAllToDiscard(params)
    local discard = params[1]
    local objects = params[2]
    if discard ~= nil then
        local destination = discard.getPosition()

        destination.x = destination.x - 1.25 * 3
        destination.z = destination.z - 1.25 * 3

        for _, object in ipairs(discard.getObjects()) do destination.y = math.max(destination.y, object.getPosition().y) end

        local row = 1
        local column = 1
        local index = 1
        for _, object in ipairs(objects) do
            local count = getAmount(object)

            if 1 < count then
                local id = object.getGUID()
                for i = 1, count do
                    local x_offset = row * 2
                    local z_offset = column * 2
                    local o = object.takeObject()
                    Wait.condition(function()
                        o.setPosition({
                            x = destination.x + x_offset,
                            y = destination.y + 3,
                            z = destination.z + z_offset
                        }, false, true)
                    end, function()
                        return o.spawning ~= true
                    end)

                    index = index + 1
                    column = column + 1
                    if 3 < column then
                        column = 1
                        row = row + 1

                        if 3 < row then row = 1 end
                    end
                end
            else

                local x_offset = row * 2
                local z_offset = column * 2
                object.setPosition({
                    x = destination.x + x_offset,
                    y = destination.y + 3,
                    z = destination.z + z_offset
                }, false, true)

                column = column + 1
                if 3 < column then
                    column = 1
                    row = row + 1

                    if 3 < row then row = 1 end
                end
            end
        end
    end
end

function cycleDiscard(player)
    local discard = getObjectFromGUID(constants.zones[player.color].discard)
    if discard ~= nil then
        local deck = getObjectFromGUID(constants.zones[player.color].deck)
        if deck ~= nil then
            for _, object in ipairs(discard.getObjects()) do
                local count = getAmount(object)
                if 1 < count then
                    local id = object.getGUID()
                    for i = 1, count do
                        local o = object.takeObject()
                        Wait.condition(function()
                            deck.putObject(o)
                            deck.shuffle()
                        end, function()
                            return o.spawning ~= true
                        end)
                    end
                else
                    deck.putObject(object)
                    deck.shuffle()
                end
            end
        end
    end
end

function shuffleDeck(player)
    local deck = getObjectFromGUID(constants.zones[player.color].deck)
    if deck ~= nil then
        local count = 5
        while 0 < count do
            deck.shuffle()
            count = count - 1
        end
    end
end

function drawMaxHand(player)
    local hand = getObjectFromGUID(constants.zones[player.color].hand)
    if hand == nil then
        broadcastToAll("Unable to find hand for player " .. player.color .. ".")
        return
    end

    local deck = getObjectFromGUID(constants.zones[player.color].deck)
    if deck == nil then
        broadcastToAll("Unable to find deck for player " .. player.color .. ".")
        return
    end

    local gem_pile = getObjectFromGUID(constants.zones[player.color].pile)
    if gem_pile == nil then
        broadcastToAll("Unable to find gem pile for player " .. player.color .. ".")
        return
    end

    local pile = getObjectFromGUID(constants.zones[player.color].deck)
    if pile == nil then
        broadcastToAll("Unable to find gem pile for player " .. player.color .. ".")
        return
    end

    -- Get gem count
    local count = countGems(gem_pile)
    local max_hand = 5
    if 9 < count then
        broadcastToAll(player.steam_name .. " tried to draw when their pile is >= 10.")
        return
    elseif 8 < count then
        max_hand = 8
    elseif 5 < count then
        max_hand = 7
    elseif 2 < count then
        max_hand = 6
    else
        max_hand = 5
    end

    -- Get hand
    if hand ~= nil then
        local hand_count = 0
        local flipped = 0
        for _, object in ipairs(hand.getObjects()) do
            if object.is_face_down then flipped = flipped + 1 end

            hand_count = hand_count + 1
        end

        local draws = max_hand - hand_count
        if 0 < draws then
            local deck_size = getAmount(deck)
            local draws_missed = draws - deck_size
            if 0 < draws_missed then
                local draws = draws - draws_missed
                deck.deal(draws, player.color)
                broadcastToColor("The deck ran out of cards. Shuffling your discard pile into your deck.", player.color)
                cycleDiscard(player)
            else
                deck.deal(draws, player.color)
            end

            if 0 < flipped then broadcastToAll(player.steam_name .. " piggy banked " .. flipped .. " cards.") end
        else
            broadcastToColor("You are already at your maximum hand size.", player.color)
        end
    end
end

function showMoney(player)
    if Turns.turn_color == player.color then
        local hand_zone = getObjectFromGUID(zones[player.color].hand)
        local count = countGems(hand_zone)
        broadcastToAll(player.steam_name .. " has $" .. count .. " in their hand.")
    else
        broadcastToColor("You can only announce your $ on your turn.", player.color)
    end
end

-- UI - Tools --

function MegaFreeze()
    local freezeByZone = {} -- Place GUIDs of script zones here
    local freezeByGUID = {
        "6b6799", -- All puzzle chips bag
        "5e08f3", -- Bottom row bank bag
        constants.character_sheet, -- Character sheet
        "f45a6c", -- Character chip platform
        "0c2d22", -- Puzzle chip platform
    } -- Place GUIDs of individual Objects here

    -- Add player mats
    for _,id in pairs(constants.player_mats) do
      table.insert(freezeByGUID, id)
    end

    -- Backgrounds for chips
    for _, id in ipairs(constants.placeholders) do
      local obj = getObjectFromGUID(id)
      obj.setLock(true)
      obj.interactable = false
    end

    for _, obj in pairs(getAllObjects()) do
      if obj.getName() == 'MegaFreeze' then
        obj.setLock(true)
        obj.interactable = false
      elseif obj.getDescription() == 'MegaFreeze' then
        obj.setLock(true)
        obj.interactable = false
      else
        for _, guid in pairs(freezeByGUID) do if obj.getGUID() == guid then obj.interactable = false end end
      end
    end

    -- Freeze Objects by Zone
    for _, zone in pairs(freezeByZone) do for _, obj in pairs(getObjectFromGUID(zone).getObjects()) do obj.interactable = false end end
end
